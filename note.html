<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>haha</title>
	<link rel="stylesheet" href="css/bower_components/bootstrap/dist/css/bootstrap.min.css">
	<script src="css/bower_components/jquery/dist/jquery.min.js"></script>
	<script src="css/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
</head>
<body>
	<script>
		function identify(){
			return this.name.toUpperCase();//变大写；
		}

		function speak(){
			var greeting = "Hello,I am  " + identify.call(this);
			console.log(greeting);
		}

		var me = {
			'name':'Kyle'
		};

		var you = {
			'name':'Reader'
		};

		var a = identify(me);//取不到值
		var b = identify.call(me);//KYLE
		console.log(a);
		console.log(b);
		//call就是把this的指向改为me的对象里；
		speak(you);//Hello,I am
		speak.call(you);//Hello,I am  READER

		var fn;

		function foo(){
			var a = 2;

			function baz() {
				console.log(a);
			}
			fn = baz;
		}

		function bar(){
			fn();
		}
		foo();
		bar();//2

		for(var i =1;i<=5;i++){
			setTimeout(function(){
				console.log(i);
			}, i*1000);
		}
		//结果是输出5次6
		//因为延迟函数的回调是在循环结束之后才运行的；
		//所有函数共享全局作用域，实际上只有一个i；要想改变结果，可以如下
			for(var i =1;i<=5;i++){
				(function(){
					setTimeout(function(){
						console.log(i);
					}, i*1000);
				})();
			}
		//但还是有问题，得不到想要的结果；因为作用内i变量是空的，我们需要将每个i的值存放到作用域内;
			for(var i =1;i<=5;i++){
				(function(){
					var j = i;
					setTimeout(function(){
						console.log(j);
					}, j*1000)
				})()
			}
		//这样才可以,还可以改进一下
			for(var i =1;i<=5;i++){
				(function(j){
					setTimeout(function(){
						console.log(j);
					}, j*1000)
				})(i)
			}
		//当然最酷的写法如下；
		for (let i =1;i<=5;i++){
			setTimeout(function(){
				console.log(i);
			}, i*1000)
		}

	</script>
</body>
</html>